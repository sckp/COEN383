#include <stdio.h>
#include <string.h>

#include <time.h>
#include <stdlib.h>

#include <sys/select.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

#include <fcntl.h>

#define BUFF_SIZE		64
#define READ_END		0
#define WRITE_END		1
#define CHILDREN		5

int main(int argc, char* argv[]) {
	// create a write and read message buffer
	char write_msg[BUFF_SIZE];
	char read_msg[BUFF_SIZE];
	
	// create array to hold the five child processes ID
	pid_t cpid[CHILDREN];
	// file descriptors for the pipe for the 5 children
	int fd[CHILDREN][2];
	
	// create a set of pipes for each child
	for(int i = 0; i < CHILDREN; i++) {
		// create the pipe
		if(pipe(fd[i]) == -1) {
			fprintf(stderr, "pipe() failed");
			return 1;
		}
	}
	
	// use a for loop to create each of the children
	for(int i = 0; i < CHILDREN; i++) {
		// fork a child process
		cpid[i] = fork();
		// check if it is the parent
		if(0 < cpid[i]) {
			// close the write end of the parent to child pipe
			close(fd[i][WRITE_END]);
		}
		// check if it is a child
		else if(0 == cpid[i]) {
			// close the read end of the childs pipe
			close(fd[i][READ_END]);
			// initialize the seed for randomization
			srand(time(NULL));
			
			// create the struct to use gettimeofday function
			struct timeval tv;
			// get the starting time
			gettimeofday(&tv, NULL);
			// set the end time of the while loop
			int endtime = tv.tv_sec + 30;
			// set the baseline time that needs to be subtracted
			int baseTime = tv.tv_sec;
			// create a variable to count the number of messages
			int msg_num = 1;
			
			// check if it is child 1-4 which does not use the terminal
			if(4 > i) {
				close(STDOUT_FILENO);
				close(STDIN_FILENO);
				while(endtime > (int)tv.tv_sec) {
					// get a random sleep time
					int sleep_time = rand() % 3;
					// sleep for the random amount of time
					sleep(sleep_time);
					// get the time of day for the message
					gettimeofday(&tv, NULL);
					
					// find out the time between messages sent
					int msg_time = (int)(tv.tv_sec - baseTime);
					double msec = (double)(tv.tv_usec/1000.00);
					
					// format the message that the child will send to the parent
					snprintf(write_msg, (sizeof(write_msg) - 1), "%i:%05.3f: Child %i message %i\n", msg_time, msec, i, msg_num);
					// write the message to the pipe
					write(fd[i][WRITE_END], write_msg, strlen(write_msg));
					
					// get the time of day for next iteration
					gettimeofday(&tv, NULL);
					msg_num++;
				}
			}
			// otherwise it is the child that reads from the terminal
			else {
				// prompt for user input
				char user_prompt[] = "Please input a string no longer than 64 characters: ";
				while(endtime > (int)tv.tv_sec) {
					char user_input[64];
					write(STDOUT_FILENO, user_prompt, sizeof(user_prompt));
					int val = read(STDIN_FILENO, user_input, 64);
					
					// get the time of day for the message
					gettimeofday(&tv, NULL);
					
					// find out the time between messages sent
					int msg_time = (int)(tv.tv_sec - baseTime);
					double msec = (double)(tv.tv_usec/1000.00);
					
					// write the child's message to the pipe
					snprintf(write_msg, sizeof(write_msg) - 1, "%i:%05.3f: Child %i: %i message from console: ", msg_time, msec, i, msg_num);
					strncat(write_msg, user_input, val);
					
					// write the message to the pipe
					write(fd[i][WRITE_END], write_msg, strlen(write_msg));
					
					// get the time of day for next iteration
					gettimeofday(&tv, NULL);
					msg_num++;
				}
			}
			// close the write end of the pipe before terminating the child
			close(fd[i][WRITE_END]);
			// have the child process exit
			_exit(EXIT_SUCCESS);
		}
		// else fork failed
		else {
			fprintf(stderr, "fork() failed");
			return 1;
		}
		
	}
	// create the output text file
	int outFD = open("output.txt", 	O_CREAT | O_RDWR);
	if(0 > outFD) {
		fprintf(stderr, "open() failed");
		exit(EXIT_FAILURE);
	}
	
	// read from all of the pipes and write to a file
	fd_set fdsets;
	struct timeval timeout;
		
	for(int i = 0; i < 30; i++) {
		// ensure that fds is zerod
		FD_ZERO(&fdsets);
		// set all of the file descriptors
		for(int i = 0; i < CHILDREN; i++) {
			FD_SET(fd[i][READ_END], &fdsets);
		}
		
		// set the timeout value
		timeout.tv_sec = 2;
		timeout.tv_usec = 500000;
		
		int retval = select(12, &fdsets, NULL, NULL, &timeout);
		printf("\n\nretval = %i\n\n", retval);
		if(-1 == retval) {
			perror("select()");
		}
		else if(retval) {
			// read from the selected file descriptor and write it to the file
			if(FD_ISSET(fd[0][READ_END], &fdsets)) {
				int val = read(fd[0][READ_END], read_msg, BUFF_SIZE);
				write(outFD, read_msg, val);
			}
			if(FD_ISSET(fd[1][READ_END], &fdsets)) {
				int val = read(fd[1][READ_END], read_msg, BUFF_SIZE);
				write(outFD, read_msg, val);
			}
			if(FD_ISSET(fd[2][READ_END], &fdsets)) {
				int val = read(fd[2][READ_END], read_msg, BUFF_SIZE);
				write(outFD, read_msg, val);
			}
			if(FD_ISSET(fd[3][READ_END], &fdsets)) {
				int val = read(fd[3][READ_END], read_msg, BUFF_SIZE);
				write(outFD, read_msg, val);
			}
			if(FD_ISSET(fd[4][READ_END], &fdsets)) {
				int val = read(fd[4][READ_END], read_msg, BUFF_SIZE);
				write(outFD, read_msg, val);
			}
		}
		else {
			printf("Select timed out\n");
		}
	}
	
	// close the output file descriptor
	close(outFD);
	
	return 0;
}
